"use strict";

/*
  app.js -- This creates an Express webserver with login/register/logout authentication
*/
// *********************************************************** //
//  Loading packages to support the server
// *********************************************************** //
// First we load in all of the packages we need for the server...
var createError = require("http-errors"); // to handle the server errors


var express = require("express");

var path = require("path"); // to refer to local paths


var cookieParser = require("cookie-parser"); // to handle cookies


var session = require("express-session"); // to handle sessions using cookies


var debug = require("debug")("personalapp:server");

var layouts = require("express-ejs-layouts");

var axios = require("axios"); // *********************************************************** //
//  Loading models
// *********************************************************** //


var ToDoItem = require("./models/ToDoItem");

var Course = require('./models/Course');

var Schedule = require('./models/Schedule'); // *********************************************************** //
//  Loading JSON datasets
// *********************************************************** //


var courses = require('./public/data/courses20-21.json'); // *********************************************************** //
//  Connecting to the database
// *********************************************************** //


var mongoose = require('mongoose'); // const mongodb_URI = 'mongodb://localhost:27017/cs103a_todo'


var mongodb_URI = 'mongodb+srv://cs_sj:BrandeisSpr22@cluster0.kgugl.mongodb.net/myFirstDatabase?retryWrites=true&w=majority';
mongoose.connect(mongodb_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true
}); // fix deprecation warnings

mongoose.set('useFindAndModify', false);
mongoose.set('useCreateIndex', true);
var db = mongoose.connection;
db.on('error', console.error.bind(console, 'connection error:'));
db.once('open', function () {
  console.log("we are connected!!!");
}); // *********************************************************** //
// Initializing the Express server 
// This code is run once when the app is started and it creates
// a server that respond to requests by sending responses
// *********************************************************** //

var app = express(); // Here we specify that we will be using EJS as our view engine

app.set("views", path.join(__dirname, "views"));
app.set("view engine", "ejs"); // this allows us to use page layout for the views 
// so we don't have to repeat the headers and footers on every page ...
// the layout is in views/layout.ejs

app.use(layouts); // Here we process the requests so they are easy to handle

app.use(express.json());
app.use(express.urlencoded({
  extended: false
}));
app.use(cookieParser()); // Here we specify that static files will be in the public folder

app.use(express["static"](path.join(__dirname, "public"))); // Here we enable session handling using cookies

app.use(session({
  secret: "zzbbyanana789sdfa8f9ds8f90ds87f8d9s789fds",
  // this ought to be hidden in process.env.SECRET
  resave: false,
  saveUninitialized: false
})); // *********************************************************** //
//  Defining the routes the Express server will respond to
// *********************************************************** //
// here is the code which handles all /login /signin /logout routes

var auth = require('./routes/auth');

var _require = require("zlib"),
    deflateSync = _require.deflateSync;

app.use(auth); // middleware to test is the user is logged in, and if not, send them to the login page

var isLoggedIn = function isLoggedIn(req, res, next) {
  if (res.locals.loggedIn) {
    next();
  } else res.redirect('/login');
}; // specify that the server should render the views/index.ejs page for the root path
// and the index.ejs code will be wrapped in the views/layouts.ejs code which provides
// the headers and footers for all webpages generated by this app


app.get("/", function (req, res, next) {
  res.render("index");
});
app.get("/about", function (req, res, next) {
  res.render("about");
});
/*
    ToDoList routes
*/

app.get('/todo', isLoggedIn, // redirect to /login if user is not logged in
function _callee(req, res, next) {
  var userId, items;
  return regeneratorRuntime.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          userId = res.locals.user._id; // get the user's id

          _context.next = 4;
          return regeneratorRuntime.awrap(ToDoItem.find({
            userId: userId
          }));

        case 4:
          items = _context.sent;
          // lookup the user's todo items
          res.locals.items = items; //make the items available in the view

          res.render("toDo"); // render to the toDo page

          _context.next = 12;
          break;

        case 9:
          _context.prev = 9;
          _context.t0 = _context["catch"](0);
          next(_context.t0);

        case 12:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[0, 9]]);
});
app.post('/todo/add', isLoggedIn, function _callee2(req, res, next) {
  var _req$body, title, description, userId, createdAt, data, item;

  return regeneratorRuntime.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.prev = 0;
          _req$body = req.body, title = _req$body.title, description = _req$body.description; // get title and description from the body

          userId = res.locals.user._id; // get the user's id

          createdAt = new Date(); // get the current date/time

          data = {
            title: title,
            description: description,
            userId: userId,
            createdAt: createdAt
          }; // create the data object

          item = new ToDoItem(data); // create the database object (and test the types are correct)

          _context2.next = 8;
          return regeneratorRuntime.awrap(item.save());

        case 8:
          // save the todo item in the database
          res.redirect('/todo'); // go back to the todo page

          _context2.next = 14;
          break;

        case 11:
          _context2.prev = 11;
          _context2.t0 = _context2["catch"](0);
          next(_context2.t0);

        case 14:
        case "end":
          return _context2.stop();
      }
    }
  }, null, null, [[0, 11]]);
});
app.get("/todo/delete/:itemId", isLoggedIn, function _callee3(req, res, next) {
  var itemId;
  return regeneratorRuntime.async(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.prev = 0;
          itemId = req.params.itemId; // get the id of the item to delete

          _context3.next = 4;
          return regeneratorRuntime.awrap(ToDoItem.deleteOne({
            _id: itemId
          }));

        case 4:
          // remove that item from the database
          res.redirect('/todo'); // go back to the todo page

          _context3.next = 10;
          break;

        case 7:
          _context3.prev = 7;
          _context3.t0 = _context3["catch"](0);
          next(_context3.t0);

        case 10:
        case "end":
          return _context3.stop();
      }
    }
  }, null, null, [[0, 7]]);
});
app.get("/todo/completed/:value/:itemId", isLoggedIn, function _callee4(req, res, next) {
  var itemId, completed;
  return regeneratorRuntime.async(function _callee4$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.prev = 0;
          itemId = req.params.itemId; // get the id of the item to delete

          completed = req.params.value == 'true';
          _context4.next = 5;
          return regeneratorRuntime.awrap(ToDoItem.findByIdAndUpdate(itemId, {
            completed: completed
          }));

        case 5:
          // remove that item from the database
          res.redirect('/todo'); // go back to the todo page

          _context4.next = 11;
          break;

        case 8:
          _context4.prev = 8;
          _context4.t0 = _context4["catch"](0);
          next(_context4.t0);

        case 11:
        case "end":
          return _context4.stop();
      }
    }
  }, null, null, [[0, 8]]);
});
/* ************************
  Functions needed for the course finder routes
   ************************ */

function getNum(coursenum) {
  // separate out a coursenum 103A into 
  // a num: 103 and a suffix: A
  i = 0;

  while (i < coursenum.length && '0' <= coursenum[i] && coursenum[i] <= '9') {
    i = i + 1;
  }

  return coursenum.slice(0, i);
}

function times2str(times) {
  // convert a course.times object into a list of strings
  // e.g ["Lecture:Mon,Wed 10:00-10:50","Recitation: Thu 5:00-6:30"]
  if (!times || times.length == 0) {
    return ["not scheduled"];
  } else {
    return times.map(function (x) {
      return time2str(x);
    });
  }
}

function min2HourMin(m) {
  // converts minutes since midnight into a time string, e.g.
  // 605 ==> "10:05"  as 10:00 is 60*10=600 minutes after midnight
  var hour = Math.floor(m / 60);
  var min = m % 60;

  if (min < 10) {
    return "".concat(hour, ":0").concat(min);
  } else {
    return "".concat(hour, ":").concat(min);
  }
}

function time2str(time) {
  // creates a Times string for a lecture or recitation, e.g. 
  //     "Recitation: Thu 5:00-6:30"
  var start = time.start;
  var end = time.end;
  var days = time.days;
  var meetingType = time['type'] || "Lecture";
  var location = time['building'] || "";
  return "".concat(meetingType, ": ").concat(days.join(","), ": ").concat(min2HourMin(start), "-").concat(min2HourMin(end), " ").concat(location);
}
/* ************************
  Loading (or reloading) the data into a collection
   ************************ */
// this route loads in the courses into the Course collection
// or updates the courses if it is not a new collection


app.get('/upsertDB', function _callee5(req, res, next) {
  var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _course, subject, coursenum, section, term, _num, num;

  return regeneratorRuntime.async(function _callee5$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          //await Course.deleteMany({})
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context5.prev = 3;
          _iterator = courses[Symbol.iterator]();

        case 5:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context5.next = 16;
            break;
          }

          course = _step.value;
          _course = course, subject = _course.subject, coursenum = _course.coursenum, section = _course.section, term = _course.term;
          _num = getNum(coursenum);
          course.num = _num;
          course.suffix = coursenum.slice(_num.length);
          _context5.next = 13;
          return regeneratorRuntime.awrap(Course.findOneAndUpdate({
            subject: subject,
            coursenum: coursenum,
            section: section,
            term: term
          }, course, {
            upsert: true
          }));

        case 13:
          _iteratorNormalCompletion = true;
          _context5.next = 5;
          break;

        case 16:
          _context5.next = 22;
          break;

        case 18:
          _context5.prev = 18;
          _context5.t0 = _context5["catch"](3);
          _didIteratorError = true;
          _iteratorError = _context5.t0;

        case 22:
          _context5.prev = 22;
          _context5.prev = 23;

          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }

        case 25:
          _context5.prev = 25;

          if (!_didIteratorError) {
            _context5.next = 28;
            break;
          }

          throw _iteratorError;

        case 28:
          return _context5.finish(25);

        case 29:
          return _context5.finish(22);

        case 30:
          _context5.next = 32;
          return regeneratorRuntime.awrap(Course.find({}).count());

        case 32:
          num = _context5.sent;
          res.send("data uploaded: " + num);

        case 34:
        case "end":
          return _context5.stop();
      }
    }
  }, null, null, [[3, 18, 22, 30], [23,, 25, 29]]);
});
app.post('/courses/bySubject', // show list of courses in a given subject
function _callee6(req, res, next) {
  var subject, courses;
  return regeneratorRuntime.async(function _callee6$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          subject = req.body.subject;
          _context6.next = 3;
          return regeneratorRuntime.awrap(Course.find({
            subject: subject,
            independent_study: false
          }).sort({
            term: 1,
            num: 1,
            section: 1
          }));

        case 3:
          courses = _context6.sent;
          res.locals.courses = courses;
          res.locals.times2str = times2str; //res.json(courses)

          res.render('courselist');

        case 7:
        case "end":
          return _context6.stop();
      }
    }
  });
});
app.get('/courses/show/:courseId', // show all info about a course given its courseid
function _callee7(req, res, next) {
  var courseId, course;
  return regeneratorRuntime.async(function _callee7$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          courseId = req.params.courseId;
          _context7.next = 3;
          return regeneratorRuntime.awrap(Course.findOne({
            _id: courseId
          }));

        case 3:
          course = _context7.sent;
          res.locals.course = course;
          res.locals.times2str = times2str; //res.json(course)

          res.render('course');

        case 7:
        case "end":
          return _context7.stop();
      }
    }
  });
});
app.get('/courses/byInst/:email', // show a list of all courses taught by a given faculty
function _callee8(req, res, next) {
  var email, courses;
  return regeneratorRuntime.async(function _callee8$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          email = req.params.email + "@brandeis.edu";
          _context8.next = 3;
          return regeneratorRuntime.awrap(Course.find({
            instructor: email,
            independent_study: false
          }));

        case 3:
          courses = _context8.sent;
          //res.json(courses)
          res.locals.courses = courses;
          res.render('courselist');

        case 6:
        case "end":
          return _context8.stop();
      }
    }
  });
});
app.post('/courses/byInst', // show courses taught by a faculty send from a form
function _callee9(req, res, next) {
  var email, courses;
  return regeneratorRuntime.async(function _callee9$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          email = req.body.email + "@brandeis.edu";
          _context9.next = 3;
          return regeneratorRuntime.awrap(Course.find({
            instructor: email,
            independent_study: false
          }).sort({
            term: 1,
            num: 1,
            section: 1
          }));

        case 3:
          courses = _context9.sent;
          //res.json(courses)
          res.locals.courses = courses;
          res.locals.times2str = times2str;
          res.render('courselist');

        case 7:
        case "end":
          return _context9.stop();
      }
    }
  });
});
app.use(isLoggedIn);
app.get('/addCourse/:courseId', // add a course to the user's schedule
function _callee10(req, res, next) {
  var courseId, userId, lookup, schedule;
  return regeneratorRuntime.async(function _callee10$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          _context10.prev = 0;
          courseId = req.params.courseId;
          userId = res.locals.user._id; // check to make sure it's not already loaded

          _context10.next = 5;
          return regeneratorRuntime.awrap(Schedule.find({
            courseId: courseId,
            userId: userId
          }));

        case 5:
          lookup = _context10.sent;

          if (!(lookup.length == 0)) {
            _context10.next = 10;
            break;
          }

          schedule = new Schedule({
            courseId: courseId,
            userId: userId
          });
          _context10.next = 10;
          return regeneratorRuntime.awrap(schedule.save());

        case 10:
          res.redirect('/schedule/show');
          _context10.next = 16;
          break;

        case 13:
          _context10.prev = 13;
          _context10.t0 = _context10["catch"](0);
          next(_context10.t0);

        case 16:
        case "end":
          return _context10.stop();
      }
    }
  }, null, null, [[0, 13]]);
});
app.get('/schedule/show', // show the current user's schedule
function _callee11(req, res, next) {
  var userId, courseIds;
  return regeneratorRuntime.async(function _callee11$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          _context11.prev = 0;
          userId = res.locals.user._id;
          _context11.next = 4;
          return regeneratorRuntime.awrap(Schedule.find({
            userId: userId
          }));

        case 4:
          _context11.t0 = function (x) {
            return x.term;
          };

          _context11.t1 = function (x) {
            return x.courseId;
          };

          courseIds = _context11.sent.sort(_context11.t0).map(_context11.t1);
          _context11.next = 9;
          return regeneratorRuntime.awrap(Course.find({
            _id: {
              $in: courseIds
            }
          }));

        case 9:
          res.locals.courses = _context11.sent;
          res.render('schedule');
          _context11.next = 16;
          break;

        case 13:
          _context11.prev = 13;
          _context11.t2 = _context11["catch"](0);
          next(_context11.t2);

        case 16:
        case "end":
          return _context11.stop();
      }
    }
  }, null, null, [[0, 13]]);
});
app.get('/schedule/remove/:courseId', // remove a course from the user's schedule
function _callee12(req, res, next) {
  return regeneratorRuntime.async(function _callee12$(_context12) {
    while (1) {
      switch (_context12.prev = _context12.next) {
        case 0:
          _context12.prev = 0;
          _context12.next = 3;
          return regeneratorRuntime.awrap(Schedule.remove({
            userId: res.locals.user._id,
            courseId: req.params.courseId
          }));

        case 3:
          res.redirect('/schedule/show');
          _context12.next = 9;
          break;

        case 6:
          _context12.prev = 6;
          _context12.t0 = _context12["catch"](0);
          next(_context12.t0);

        case 9:
        case "end":
          return _context12.stop();
      }
    }
  }, null, null, [[0, 6]]);
}); // here we catch 404 errors and forward to error handler

app.use(function (req, res, next) {
  next(createError(404));
}); // this processes any errors generated by the previous routes
// notice that the function has four parameters which is how Express indicates it is an error handler

app.use(function (err, req, res, next) {
  // set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get("env") === "development" ? err : {}; // render the error page

  res.status(err.status || 500);
  res.render("error");
}); // *********************************************************** //
//  Starting up the server!
// *********************************************************** //
//Here we set the port to use between 1024 and 65535  (2^16-1)

var port = "5000";
app.set("port", port); // and now we startup the server listening on that port

var http = require("http");

var server = http.createServer(app);
server.listen(port);

function onListening() {
  var addr = server.address();
  var bind = typeof addr === "string" ? "pipe " + addr : "port " + addr.port;
  debug("Listening on " + bind);
}

function onError(error) {
  if (error.syscall !== "listen") {
    throw error;
  }

  var bind = typeof port === "string" ? "Pipe " + port : "Port " + port; // handle specific listen errors with friendly messages

  switch (error.code) {
    case "EACCES":
      console.error(bind + " requires elevated privileges");
      process.exit(1);
      break;

    case "EADDRINUSE":
      console.error(bind + " is already in use");
      process.exit(1);
      break;

    default:
      throw error;
  }
}

server.on("error", onError);
server.on("listening", onListening);
module.exports = app;